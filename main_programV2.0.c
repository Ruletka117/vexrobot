#pragma config(Sensor, port2,  touchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port3,  colorSensor,    sensorVexIQ_Color12Color)
#pragma config(Sensor, port4,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port5,  bumperSwitch,   sensorVexIQ_Touch)
#pragma config(Sensor, port8,  distanceMM,     sensorNone)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor9,          clawMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         armMotor,      tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Code above is generated by VEX's IDE, you can configure port's connections
//Task was to navigate through map, detect and grab tennis ball, detect the red cube and throw the ballover the edge
//During colibration of variables it is advisible to use TouchLED sensor, so you can see which point of your program should be modified
//Later it's beter to remove touch led to save on weight
//Distance sensor isn't used here, but never use == operator.


//Function helps robot to drive on the sraight line colibrating any yaw movement
//Neglets affect of one motor being weaker than other
void driveStraight(float angle, int correction, int speed)
{
	setTouchLEDColor(touchLED, colorGreen);
	resetGyro(gyroSensor);
	setMultipleMotors(speed,leftMotor,rightMotor);
	do{
		if(getGyroDegreesFloat(gyroSensor)>=angle)
		{
			setMotor(leftMotor,speed+correction);
			setMotor(rightMotor,speed-correction);
		}
		if(getGyroDegreesFloat(gyroSensor)<=-angle)
		{
			setMotor(rightMotor,speed+correction);
			setMotor(leftMotor,speed-correction);
		}
		if((getGyroDegreesFloat(gyroSensor)<=0.8)&&(getGyroDegreesFloat(gyroSensor)>=-0.8))
		{
			setMultipleMotors(speed,leftMotor,rightMotor);
		}
	}
	while(getBumperValue(bumperSwitch)!=1);
	stopAllMotors();
}


//Turn function
//dgr value really depends on conditions of gyro
void turn(bool left,float dgr,int turnspeed) //True means left turn, false means right turn
{
	setTouchLEDColor(touchLED, colorYellow);
	resetGyro(gyroSensor);
	if(left)
	{
		setMotor(leftMotor,-turnspeed);
		setMotor(rightMotor,turnspeed);
		waitUntil(getGyroDegreesFloat(gyroSensor)>=dgr);
		stopMultipleMotors(leftMotor,rightMotor);
	}
	else
	{
		setMotor(leftMotor,turnspeed);
		setMotor(rightMotor,-turnspeed);
		waitUntil(getGyroDegreesFloat(gyroSensor)<=-dgr);
		stopMultipleMotors(leftMotor,rightMotor);
	}
}


//Grabing function
void grab(bool get, int armdgr, int clawdgr,float time, int grabspeed)// True for grabbing, False for dropping
{
	setTouchLEDColor(touchLED, colorBlue);
	setMultipleMotors(-grabspeed, leftMotor, rightMotor);          			// Negative speed for dropping
	wait(time);
	stopMultipleMotors(leftMotor, rightMotor);
	if(get==true)
	{
		moveMotor(clawMotor, clawdgr, degrees, grabspeed);
		moveMotor(armMotor, armdgr, degrees, grabspeed);
	}
	else
	{
		moveMotor(armMotor, armdgr, degrees, grabspeed);
		moveMotor(clawMotor, clawdgr, degrees, grabspeed);
	}
}


//Search for red cube function
//Same as driving but uses colorsensor's data 
//Can react to human hands
void searchForRed(float angle,int correction, int speed)
{
	setTouchLEDColor(touchLED,colorRed);
	resetGyro(gyroSensor);
	setMultipleMotors(speed,leftMotor,rightMotor);
	do{
		if(getGyroDegreesFloat(gyroSensor)>=angle)
		{
			setMotor(leftMotor,speed+correction);
			setMotor(rightMotor,speed-correction);
		}
		if(getGyroDegreesFloat(gyroSensor)<=-angle)
		{
			setMotor(rightMotor,speed+correction);
			setMotor(leftMotor,speed-correction);
		}
		if((getGyroDegreesFloat(gyroSensor)<=0.8)&&(getGyroDegreesFloat(gyroSensor)>=-0.8))
		{
			setMultipleMotors(speed,leftMotor,rightMotor);
		}
	}
	while(getColorName(colorSensor)!= colorRed);
	stopAllMotors();
}


//All the variables can be changed here
//Code is very flexible
task main()
{
	driveStraight(1.75, 10, 100);
	grab(true, 700, 70, 0.2, 100);
	turn(true, 85.0, 100);
	wait(0.1);
	driveStraight(1.75, 10, 100);
	turn(true, 80.0, 100);
	wait(0.1);
	searchForRed(1.75, 5, 95);
	turn(false, 77.5, 100);
	grab(false, -500, -70, 0.4, -100);
}
